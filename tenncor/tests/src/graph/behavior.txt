// REACTIVE BEHAVIOR
A000 - copying subjects do not copy over audiences
        moving subjects move over audiences
        subjects without audience will return false if it has no observers
A001 - subjects notify all observers
        if UNSUBSCRIBE is called, then observer will suicide via commit_sudoku
        if UPDATE is called, then observer will update via
        public update with subject being its input
A002 - destroying a subject will destroy their observers via UNSUBSCRIBE update,
        and via commit_sudoku
A003 - attaching observer to subject at index means notifying the
        observer's protected update is triggered with calling subject and the index specified
        attaching does nothing to update observer's dependency (not tested)
A004 - detaching observer with index mean the above behavior will not hold for the specific index
        detaching observer without index will prevent above behavior from holding
        for any specific index to observer
        detaching does nothing to update observer's dependency (not tested)

A005 - constructing observer with dependencies should automatically attach
        constructed observer to designated subjects
A006 - copying/moving observers copy/move over dependencies
A007 - add_dependency with observer attaches observer to subject with index = dependencies_.size()
        additionally, push subject back to dependencies
A008 - remove_dependency with observer detaches observer from subject at specified index
        dependency at index is set to nullptr
A009 - replace_dependency at index detaches the last subject at index, attaches new subject at index
        and replace subject in dependencies at index
A010 - destroying an observer will detach the observer from its subjects via a detach call

// NODE BEHAVIOR



// VARIABLE DEPENDENT OBJECTS
C000 - session should register all variable nodes on node construction
C001 - session should unregister all destroyed variable nodes
C002 - session should be singleton per thread
C003 - session should be able to initialize all initialisable variables of a specific type

D000 - initialization of unallocated tensors will fail
D001 - random initializers must share a distribution engine

// VARIABLE LEAF NODES
D100 - ileaf inheriteds should auto notify when initialized or reinitialized
D200 - variables auto initialize scalar on construction
D201 - variable's gradient is a one variable
D300 - assigning raw data or tensors to placeholders will initialize it
D301 - placeholders can be initialized at construction, this initializer will be promptedly destroyed
D302 - placeholder's gradient is a zero constant
D400 - constants must self destruct when its subject loses all its subscribers
D401 - constants are always initialized
D402 - constant's gradient is a zero constant

// BASE OPERATION NODE
F000 - operation holding poorly defined tensors (null inputs) return null on evaluation
F001 - operation must reuse its gradient object
F002 - exposing operation nodes with null/invalid tensors will fail

F100 - elementary operations must error on exposure when not all of its leaves are initialized
F101 - binary operations must fail when its argument shapes are do not match (by the rules of the operation) at constructing if shape_eval is enabled, or at exposure on all others
F102 - elementary binary operations argument shapes must be equivalent (same rank, and dimensional values)
F103 - matrix operations only takes 2-D tensors
F104 - matrix operations argument shapes must match by according to the following (<m, n>, <k, m>) where m is indice 0, and 1 for first and second argument respectively (this indicates column is index 0)

F200 - each graph instance builds from a single variable; deleting graph will not change the variable
F201 - graphs created from append_graph methods will preserve the input graph

F300 - conditional's eval, shape, gradient, and jacobian are obtained from its active dependency (except for jacobian, and gradient; undefined behavior for now)
F301 - not_zero's active dependency is non-zero (scalar or otherwise) and is initialized (get_eval is non-null)
F302 - push_toggle activation will notify its dependencies of activation once, then return to default state
F303 - push_toggle activation value will linger until explicitly called to update again
F304 - when binding bindable_toggle, bound variables will reset and update previously active toggles
F305 - binding toggles will return a unique value dictating unique bind relationships; different relationships have different bound vector

// VARIABLE NODE EXECUTORS
G000 - iexecutor should prevent its destination from being updated when its source nodes notify
G001 - iexecutor should remove its source nodes when they are destroyed
G002 - iexecutor should remove its destination nodes when they are destroyed
G003 - group should execute its executors in order of when they are added
