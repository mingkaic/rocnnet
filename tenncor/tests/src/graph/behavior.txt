// REACTIVE BEHAVIOR
A000 - copying subjects do not copy over audiences
        moving subjects move over audiences
        subjects without audience will return false if it has no observers
A001 - subjects notify all observers
        if UNSUBSCRIBE is called, then observer will suicide via commit_sudoku
        if UPDATE is called, then observer will update via
        public update with subject being its input
A002 - destroying a subject will destroy their observers via UNSUBSCRIBE update,
        and via commit_sudoku
A003 - attaching observer to subject at index means notifying the
        observer's protected update is triggered with calling subject and the index specified
        attaching does nothing to update observer's dependency (not tested)
A004 - detaching observer with index mean the above behavior will not hold for the specific index
        detaching observer without index will prevent above behavior from holding
        for any specific index to observer
        detaching does nothing to update observer's dependency (not tested)

A005 - constructing observer with dependencies should automatically attach
        constructed observer to designated subjects
A006 - copying/moving observers copy/move over dependencies
A007 - add_dependency with observer attaches observer to subject with index = dependencies_.size()
        additionally, push subject back to dependencies
A008 - remove_dependency with observer detaches observer from subject at specified index
        dependency at index is set to nullptr. trim all nullptrs from end of dependencies
A009 - replace_dependency at index detaches the last subject at index, attaches new subject at index
        and replace subject in dependencies at index
A010 - destroying an observer will detach the observer from its subjects via a detach call

// NODE BEHAVIOR
B000 - cloning inode creates another node of the same label, but different uid,
        moving prevents coping over uid
B001 - a uid is unique for every instance of node
B002 - label is a non-unique string assigned during construction,
        name is the concatenation of uid and label

// CONNECTOR BEHAVIOR
C000 - copying connector copies over graph id if the original connector has at least one
        connector dependency (conform to definition of same graph)
        moving moves over graph id regardless, moving gid_ will nullptr the original gid_ pointer
        creating a connector of a connector with null gid_ (possible with moving) will throw
C001 - connector name is the name of the connecting node in <> braces and
        its dependencies' labels separated by commas in () brackets
C002 - connector is the same graph as another connector if they share a common connector
        along its dependency graph.
C003 - connector potential descendent calls both this and other connnector get_leaves to get leaf set

// IMMUTABLE BEHAVIOR (Not tested)
D000 - cloning and moving immutable copies and moves over data, Nf_ and ginit_
D001 - immutable A is a potential descendent of connector B if A's leaf set is a subset of B's leaf set
D002 - immutable has good status if all its children are good, otherwise it's bad
D003 - immutable tensor shape is the result of the shaper function.
        bad status returns an undefined tensorshape
D004 - immutable tensor initializes its tensor from the forward transfer functions if all its arguments are good
        otherwise good status is false, bad status returns nullptr on get_eval
D005 - immutable dies when any of its dependencies dies
D006 - temporary_eval grabs the resulting value from target node up to calling node.
        the target node's value is taken as scalar 1.
        tensor is allocated and is owned by the caller.
        (meaning deleting the resulting tensor should have no adverse affect on any object state)
D007 - immutable get_leaves return a map from leaf to nullptr
D008 - given an input of leaf A, get_leaf returns the node mapped by A in
        back_map (provided during construction). leaf A is back_map's second argument.
D009 - get_gradient applies jacobian transformations regardless of its input leaf node
        if wrt is this, base result (without jacobian) is scalar 1,
        else if wrt is not a leaf but is a potential descendent, base result is evaluation from wrt to this
        else if wrt is not a leaf and isn't a potential descendent, the base result is scalar 0
        otherwise the base result is the non-null value mapped from gcache
D010 - update explicitly runs its forward transfer function with current depdendency states as its argument

// ELEMENTARY BEHAVIORS
E000 -

// TRANSFORM BEHAVIORS
F000 -

// MATMUL BEHAVIOR
G000 -



- exposing operation nodes with null/invalid tensors will fail
- elementary operations must error on exposure when not all of its leaves are initialized
- binary operations must fail when its argument shapes are do not match (by the rules of the operation) at constructing if shape_eval is enabled, or at exposure on all others
- elementary binary operations argument shapes must be equivalent (same rank, and dimensional values)
- matrix operations only takes 2-D tensors
- matrix operations argument shapes must match by according to the following (<m, n>, <k, m>) where m is indice 0, and 1 for first and second argument respectively (this indicates column is index 0)


// LEAF BEHAVIOR
H000 -

// CONSTANT BEHAVIOR
I000 -

// IVARIABLE BEHAVIOR
J000 -

// VARIABLE BEHAVIOR
K000 -

// PLACEHOLDER BEHAVIOR
L000 -


// VARIABLE LEAF NODES
- ileaf inheriteds should auto notify when initialized or reinitialized
- variables auto initialize scalar on construction
- variable's gradient is a one variable
- assigning raw data or tensors to placeholders will initialize it
- placeholders can be initialized at construction, this initializer will be promptedly destroyed
- placeholder's gradient is a zero constant
- constants must self destruct when its subject loses all its subscribers
- constants are always initialized
- constant's gradient is a zero constant

